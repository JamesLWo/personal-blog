<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2021-05-19T14:26:04-05:00</updated><id>/feed.xml</id><title type="html">James’ Blog</title><subtitle></subtitle><entry><title type="html">House Robber 2 - Problem Reduction</title><link href="/lc/algorithms/house-robber/2021/05/19/House-Robber-2-Problem-Reduction.html" rel="alternate" type="text/html" title="House Robber 2 - Problem Reduction" /><published>2021-05-19T13:29:00-05:00</published><updated>2021-05-19T13:29:00-05:00</updated><id>/lc/algorithms/house-robber/2021/05/19/House%20Robber%202%20-%20Problem%20Reduction</id><content type="html" xml:base="/lc/algorithms/house-robber/2021/05/19/House-Robber-2-Problem-Reduction.html">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;I like House Robber 2 because we do not have to do much to get the solution. It showcases a cool example of problem reduction - reducing a problem down to another problem. In problem reduction, if you have the solution too the equivalent problem, you also have the solution to the original problem! So the only challenge here is recognizing the problem is similar to one you have done before (in this case, it’s House Robber 1!)&lt;/p&gt;

&lt;p&gt;The problem specification: The objective, constraints, and input are the same as the ones in House Robber 1. The difference is that the houses are arranged in a circle, meaning the first house is next to the second house…and that’s the only difference.&lt;/p&gt;

&lt;p&gt;Original problem can be found &lt;a href=&quot;https://leetcode.com/problems/house-robber-ii/&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;recognition&quot;&gt;Recognition&lt;/h2&gt;
&lt;p&gt;Important observation: Because the first and last houses are adjacent, we only have two options. The first option is that we consider choosing the first and ignore the last, or we consider choosing the last and ignore the first (recall in House Robber 1: if we pick a house, we no longer consider adjacent houses). Either way, we of course will consider all elements in between aas well.&lt;/p&gt;

&lt;p&gt;Let’s rephrase the two options. For the first option, since we ignore the last house, our answer can be found by finding the maximum total value when considering the first n-1 elements. For the second option, since we ignore the first house, our answer can be found by finding the maximum value when considering the last n-1 elements. Sound familiar? The solution to each option is just running House Robber 1 on a subarray.&lt;/p&gt;

&lt;h2 id=&quot;algorithm&quot;&gt;Algorithm&lt;/h2&gt;
&lt;p&gt;The algorithm kind of follows immediately from recognition - you can just run your solution to House Robber 2 two times, the only thing that changes is input. You can then return the best of the two options&lt;/p&gt;

&lt;h2 id=&quot;code&quot;&gt;Code&lt;/h2&gt;
&lt;p&gt;My solution:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
public int rob(int[] nums) {
    if(nums.length ==1) return nums[0];
	return Math.max(originalRobberProblem(Arrays.copyOfRange(nums,0,nums.length-1)), originalRobberProblem(Arrays.copyOfRange(nums,1,nums.length)));

}

public int originalRobberProblem(int[] nums){
    int prevBest = 0;
	int currentBest = 0;
	for(int num : nums){
		//choice of taking num
		int temp = currentBest;
		currentBest = Math.max(num + prevBest, currentBest);
		prevBest = temp;
	}
	return currentBest;



}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="lc" /><category term="algorithms" /><category term="house-robber" /><summary type="html">Introduction I like House Robber 2 because we do not have to do much to get the solution. It showcases a cool example of problem reduction - reducing a problem down to another problem. In problem reduction, if you have the solution too the equivalent problem, you also have the solution to the original problem! So the only challenge here is recognizing the problem is similar to one you have done before (in this case, it’s House Robber 1!)</summary></entry><entry><title type="html">House Robber 1 - Classic DP</title><link href="/lc/algorithms/house-robber/2021/05/15/House-Robber-1.html" rel="alternate" type="text/html" title="House Robber 1 - Classic DP" /><published>2021-05-15T22:20:00-05:00</published><updated>2021-05-15T22:20:00-05:00</updated><id>/lc/algorithms/house-robber/2021/05/15/House%20Robber%201</id><content type="html" xml:base="/lc/algorithms/house-robber/2021/05/15/House-Robber-1.html">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;The House Robber problem introduces a pretty canonical dynamic programming approach so it’s a good starting point to getting comfortable with DP. I’ll probably write an introductory article eventually about DP, but this post will asssume some basic understanding.&lt;/p&gt;

&lt;p&gt;The problem specification is pretty straight forward - you have an array of integers, where each number represents a value (presumably representing a house with some value waiting to be robbed?). You, as a robber, need to strategically pick values (rob the houses) such that you &lt;strong&gt;&lt;em&gt;maximize the total value&lt;/em&gt;&lt;/strong&gt; while &lt;strong&gt;&lt;em&gt;avoid picking two adjacent values&lt;/em&gt;&lt;/strong&gt;. So in typical fashion, you have an objective and a constraint.&lt;/p&gt;

&lt;p&gt;Problem can be found &lt;a href=&quot;https://leetcode.com/problems/house-robber/&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;first-intuition-greedy-approach&quot;&gt;First intuition: Greedy Approach?&lt;/h2&gt;
&lt;p&gt;When I first read this problem after taking an algo class at my uni, I didn’t even recognize it as a DP problem (that’s usually 50% of the challenge with DP, recognizing it’s DP…). my first instinct was a greedy algorithm, where we naively compare two options. The first option would be to pick the even-indexed numbers (numbers at index 0, 2, 4, …). The second option would be to pick the odd-indexed numbers (numbers at index 1, 3 , 5, …). After all, these are the only two options that can allow us to pick the maximum number of values, no? Why even ignore a house when you can greedily pick it?&lt;/p&gt;

&lt;h2 id=&quot;problem-with-greedy-approach&quot;&gt;Problem with Greedy Approach&lt;/h2&gt;
&lt;p&gt;Well, maximizing number of values chosen != maximizing total value&lt;/p&gt;

&lt;p&gt;Consider the following array: [100, 1, 1, 100, 1]&lt;/p&gt;

&lt;p&gt;With our first approach, we get a total value of 102. With our second, we also get a total value of 102. But we know the answer is 200 here.&lt;/p&gt;

&lt;p&gt;So what can we do?&lt;/p&gt;

&lt;h2 id=&quot;brief-dp-discussiondetour&quot;&gt;Brief DP Discussion/Detour&lt;/h2&gt;
&lt;p&gt;Again, I’ll probably write another post talking about DP more in depth, but two important points/reminders:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;DP will always involve optimal substructure. This just means the answer to a problem will depend on the answer to the problem’s subproblems&lt;/li&gt;
  &lt;li&gt;Because a problem can be broken down into subproblems, we can form some sort of recurrence relation&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;algorithm&quot;&gt;Algorithm&lt;/h2&gt;
&lt;p&gt;So with those 2 points, let’s make an important observaton here:&lt;/p&gt;

&lt;p&gt;Assume we have an instance of the problem, say [5,4,6,7,1,1]. Let’s say we already know the maximum value we can get when considering the first 2 elements (5,4), which is 5. Let’s say we also already know the maximum value we can get by only considering the first 3 elements (5,4,6), which is 11.  Now, can we quickly find the maximum value we can get by considering the first 4 elements?. After all, we didn’t really change the problem all that much right? By considering one more element, there isn’t too much burden with overchoice here: &lt;strong&gt;&lt;em&gt;Really, we have two choices: we can either choose to include 7, or we choose not to include 7.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Let’s say we choose 7. Well, that just means we cannot pick 6, since it is adjacent to 7. With this restriction, we can reason that &lt;strong&gt;&lt;em&gt;the best we can do is try to find the maximum total value that ignores the value 6.&lt;/em&gt;&lt;/strong&gt; Recall the original problem we’re trying to solve is finding the maximum value considering the first 4 elements. Right now, we’re choosing 7 (the 4th element) and consequently we are forced to ignore 6 (the 3rd element). So now we must ask: how can we optimally choose the remaining values (the 1st and 2nd element)? After all, if we know the maximum sum for the remaining values, adding 7 this sum will give us the maximum value when considering the first 4 elements and picking the fourth element. The trick is that this maximum sum is already known! Recall that we assumed we already know the maximum value we can get by considering the first 2 elements, so calculating this is really fast!&lt;/p&gt;

&lt;p&gt;Let’s consider the only other option: not picking 7. If you don’t pick 7, you’re free to pick 6 if you would like. There’s no restriction here. If we don’t pick 7, then our answer would just be the maximum total value we can get by considering the rest of the values (5,4,6). Do we know this? Yes! We already know the maximum value we can get when considering the first 3 elements.&lt;/p&gt;

&lt;p&gt;So similar to the greedy approach, we’re considering two options and picking the maximumm of the two. The only difference is that our two options are much more informed :)&lt;/p&gt;

&lt;p&gt;Let’s tie things up real quick. We now have the solution when we consider the first 4 elements. We also have the solution when considering the first 3 elements. Now, we can repeat the logic above to get the answer for the first 5 elements! You can see that we can repeat this process until we reach the solution when considering all the elements!&lt;/p&gt;

&lt;p&gt;So the recurrence relation should be clear now. More formally, if we know f(i-1) and f(i-2), we can find out f(i) quickly (kind of like fibonacci right?). To clarify, f(i) here would represent the maximum value we can get when considering the first i elements. f(i) would then be the maximum between values[i] + f(i-2) and f(i-1).&lt;/p&gt;</content><author><name></name></author><category term="lc" /><category term="algorithms" /><category term="house-robber" /><summary type="html">Introduction The House Robber problem introduces a pretty canonical dynamic programming approach so it’s a good starting point to getting comfortable with DP. I’ll probably write an introductory article eventually about DP, but this post will asssume some basic understanding.</summary></entry></feed>